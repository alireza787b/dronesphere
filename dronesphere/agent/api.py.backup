"""Agent FastAPI application - single drone operations.

This module provides the FastAPI application for the DroneSphere agent,
handling single drone control and monitoring operations.
"""

import time
from typing import Optional

from fastapi import FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware

from dronesphere.core.models import (
    APIResponse, CommandSequence, CommandAcceptedResponse, 
    DroneStatus, Telemetry, CommandEnvelope
)
from dronesphere.core.errors import CommandValidationError
from dronesphere.core.logging import get_logger
from .instance import get_agent  # Use instance module instead of main
from .config import get_agent_settings

logger = get_logger(__name__)
settings = get_agent_settings()

# Create FastAPI app
app = FastAPI(
    title="DroneSphere Agent API",
    description="Single drone control and monitoring",
    version="1.0.0"
)

# Add CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Configure properly for production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/ping")
async def ping():
    """Agent connectivity check."""
    return {
        "status": "ok",
        "timestamp": time.time(),
        "agent_id": get_agent().drone_id
    }

@app.get("/health") 
async def health():
    """Agent and hardware health check."""
    try:
        agent = get_agent()
        
        if not agent.connection or not agent.connection.connected:
            return {
                "status": "unhealthy",
                "agent": "ok", 
                "hardware": "disconnected",
                "timestamp": time.time()
            }
            
        # Get hardware state
        state = await agent.connection.get_state()
        telemetry = await agent.connection.get_telemetry()
        
        hardware_status = "ok"
        if telemetry and not telemetry.health_all_ok:
            hardware_status = "degraded"
            
        return {
            "status": "healthy" if hardware_status == "ok" else "degraded",
            "agent": "ok",
            "hardware": hardware_status,
            "drone_state": state,
            "timestamp": time.time()
        }
        
    except Exception as e:
        logger.error("health_check_failed", error=str(e))
        return {
            "status": "unhealthy",
            "agent": "error", 
            "hardware": "unknown",
            "error": str(e),
            "timestamp": time.time()
        }

@app.get("/status")
async def get_status():
    """Get current drone status."""
    try:
        agent = get_agent()
        
        if not agent.connection:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Drone not connected"
            )
            
        state = await agent.connection.get_state()
        current_execution = agent.runner.get_current_execution() if agent.runner else None
        queue_length = agent.runner.get_queue_size() if agent.runner else 0
        
        # Get last telemetry timestamp
        telemetry = await agent.connection.get_telemetry()
        last_telemetry = telemetry.timestamp if telemetry else None
        
        health_status = "ok" if agent.connection.connected else "disconnected"
        if telemetry and not telemetry.health_all_ok:
            health_status = "degraded"
            
        return DroneStatus(
            drone_id=agent.drone_id,
            state=state,
            current_command=current_execution,
            queue_length=queue_length,
            last_telemetry=last_telemetry,
            health_status=health_status
        )
        
    except Exception as e:
        logger.error("get_status_failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get status: {str(e)}"
        )

@app.get("/telemetry")
async def get_telemetry():
    """Get current drone telemetry."""
    try:
        agent = get_agent()
        
        if not agent.connection:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Drone not connected"
            )
            
        telemetry = await agent.connection.get_telemetry()
        
        if not telemetry:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Telemetry not available"
            )
            
        return telemetry
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error("get_telemetry_failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get telemetry: {str(e)}"
        )

@app.post("/commands")
@app.post("/commands")
async def execute_commands(command_sequence: CommandSequence):
    """Execute command sequence on this drone."""
    try:
        agent = get_agent()
        
        if not agent.runner:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Command runner not available"
            )
            
        logger.info("command_request_received", 
                   sequence_length=len(command_sequence.sequence))
        
        # Create command envelope
        envelope = CommandEnvelope(
            drone_id=agent.drone_id,
            sequence=command_sequence.sequence
        )
        
        # Enqueue command
        command_id = await agent.runner.enqueue_command(envelope)
        
        # Estimate duration
        estimated_duration = len(command_sequence.sequence) * 30
        
        logger.info("command_accepted", 
                   command_id=command_id,
                   estimated_duration=estimated_duration)
        
        # FIX: Return proper JSON response
        return {
            "success": True,
            "message": "Command sequence accepted",
            "command_id": command_id,
            "estimated_duration": estimated_duration
        }
        
    except CommandValidationError as e:
        logger.warning("command_validation_failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e)
        )
    except Exception as e:
        logger.error("command_execution_failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Command execution failed: {str(e)}"
        )
        )

@app.get("/commands")
async def list_commands():
    """List available commands."""
    try:
        from dronesphere.commands.registry import get_command_registry
        registry = get_command_registry()
        
        return APIResponse(
            success=True,
            message="Available commands",
            data={
                "commands": registry.list_commands(),
                "total": len(registry.list_commands())
            }
        )
        
    except Exception as e:
        logger.error("list_commands_failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to list commands: {str(e)}"
        )

@app.post("/emergency_stop")
async def emergency_stop():
    """Execute emergency stop."""
    try:
        agent = get_agent()
        
        logger.warning("emergency_stop_requested")
        
        if not agent.connection:
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Drone not connected"
            )
            
        # Stop runner and emergency stop drone
        if agent.runner:
            await agent.runner.stop()
            
        await agent.connection.emergency_stop()
        
        # Restart runner
        if agent.runner:
            await agent.runner.start()
            
        logger.warning("emergency_stop_executed")
        
        return APIResponse(
            success=True,
            message="Emergency stop executed"
        )
        
    except Exception as e:
        logger.error("emergency_stop_failed", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Emergency stop failed: {str(e)}"
        )
